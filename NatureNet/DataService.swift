//
//  DataService.swift
//  NatureNet
//
//  Created by Mohammad Javad Mahzoon on 5/20/17.
//  Copyright Â© 2017 NatureNet. All rights reserved.
//

import Foundation
import Firebase

// This class is a singleton, meaning only one instance is going to be created from this class. That only instance is DataService.ds
// So, to use this class call its function by referencing the only instance, like this: DataService.ds.SignOut()
class DataService  {
    
    // This is the only instance of this singleton class
    static let ds = DataService()
    
    // reference to the Firebase "real-time database"
    private var db_ref: DatabaseReference!
    
    // The current user is either nil which means nobody is logged-in in the device, or it has a value indicating some user is logged in. This is a private member and is referenced only in the class functions for example in the LoggedIn() function.
    private var currentUser: User?
    
    // The sites dictionary contains siteId -> siteName. It will be initialized in the init, and the function "GetSites" returns it.
    private var sites: [String:String]!
    // reference to the observer handle of sites. This observer looks for changes in sites, and updates the "sites" array if new site is being added, or changed. The reference is mainly for "dispose" to remove the handle.
    private var sitesHandle: UInt!
    
    init() {
        // initializing the reference to the database
        db_ref = Database.database().reference()
        // initializing sites array
        self.sites = [String:String]()
        // adding observer to the sites
        sitesHandle = db_ref.child(DB_SITES_PATH).observe(.value, with: { (snapshot) in
            // snapshot will be the whole "sites" key with its children to the leaf. For example, if site/aces/description value changes, added, or removed, the whole sites/ will be returned. So, we can replace the "sites" array with site names in the snapshot.
            if let sitesDict = snapshot.value as? [String:[String:AnyObject]] {
                // the sitesDict is like "siteId" -> { "key" -> <object> } (the "key" we are interested in is "name")
                for (siteId, v) in sitesDict {
                    if let siteName = v["name"] as? String {
                        self.sites[siteId] = siteName
                    }
                }
            }
        })
    }
    
    func dispose() {
        sites = nil
        currentUser = nil
        // remove site observer
        db_ref.removeObserver(withHandle: sitesHandle)
    }
    
    // To authenticate a user using email/password use this function. Upon success, the function calls the "completion" callback parameter with "true" and empty string parameters. If there is any error in signing in, then the parameters of "completion" callback would be false (indicating that the sign in process was not successful) and error string. The error string is generated by Firebase, and is hopefully desciptive enough about the error.
    func Authenticate(email: String, pass: String,
                             completion: @escaping (Bool, String) -> Void) {
        
        Auth.auth().signIn(withEmail: email, password: pass) { (user, error) in
            self.currentUser = user
            if let e = error {
                // the localized description contains error's description
                completion(false, e.localizedDescription)
            } else {
                completion(true, "")
            }
        }
    }
    
    // To check if anybody is logged-in in this device, call this. It returns true if somebody is logged in and false otherwise.
    func LoggedIn() -> Bool {
        if currentUser == nil {
            // if currentUser is nil, we need to check Firebase auth again. Maybe we lost the user, but the user is still logged in. A typical scenario which supports this case is that the user logged-in but closes the app. The user is still logged in but the app looses the pointer to the currentUser.
            if Auth.auth().currentUser == nil {
                return false
            } else {
                // update our pointer to the current user
                self.currentUser = Auth.auth().currentUser
                return true
            }
        }
        return true
    }
    
    // To signout user from Firebase, call this function. SignOut returns a tuple containing result status as a boolean and error if any as a string. In case of successful signout, the return value will be (true, ""). But, in case of error the return value will be (false, <error description>).
    func SignOut() -> (Bool, String){
        do {
            try Auth.auth().signOut()
        } catch let signOutError as NSError {
            return (false, signOutError.localizedDescription)
        }
        currentUser = nil
        return (true, "")
    }
    
    // returns a reference to the sites dictionary. For example, this is used in the join or profile screen to show options for selecting sites.
    func GetSites() -> [String:String] {
        return sites
    }
    // returning only site names sorted by their Ids
    func GetSiteNames() -> [String] {
        return sites.sorted(by: {$0.key < $1.key}).map{(k, v) -> String in return v}
    }
}
